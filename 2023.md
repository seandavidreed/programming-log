# Year: 2023

---
### Table of Contents
[January](#112023)  
[February](#212023)

### Resources
[C++ Initialization](https://stackoverflow.com/questions/18222926/what-are-the-advantages-of-list-initialization-using-curly-braces) *1/5/2023*  
[What is a Semiconductor?](https://www.techtarget.com/whatis/definition/semiconductor) *1/14/2023*  
[Static Variables in C](https://www.geeksforgeeks.org/static-variables-in-c/) *1/15/2023*  
[Memory Layout of C Programs](https://www.geeksforgeeks.org/memory-layout-of-c-program/) *1/15/2023*  
[What is constinit in C++](stackoverflow.com/questions/57845131/what-is-constinit-in-c20) *1/18/2023*  
[Understanding constexpr in C++](geeksforgeeks.org/understanding-constexper-specifier-in-cpp/) *1/18/2023*  
[Lecture on constexpr](youtube.com/watch?v=fZjYCQ8dzTc&t=6s) *1/19/2023*  
[C++ Graph Implementation](https://www.techiedelight.com/graph-implementation-c-without-using-stl/) *1/21/2023*  
[More on Graphs](https://www.geeksforgeeks.org/introduction-to-graphs-data-structure-and-algorithm-tutorials/?ref=lbp) *1/22/2023*  
[What is a Git SSH Key?](https://www.atlassian.com/git/tutorials/git-ssh) *1/22/2023*  
[GitHub SSH Key Fingerprints](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints) *1/22/2023*  
[Character Strings in C](https://www.cs.uic.edu/~jbell/CourseNotes/C_Programming/CharacterStrings.html) *1/25/2023*  
[adafruit PIR Motion Sensor](https://learn.adafruit.com/pir-passive-infrared-proximity-motion-sensor/testing-a-pir) *1/25/2023*  
[Learn DSA](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=shm) *1/27/2023*  
[Time Complexity Examples](https://stackoverflow.com/questions/1592649/examples-of-algorithms-which-has-o1-on-log-n-and-olog-n-complexities) *1/27/2023*  
[Circular Linked List Split](https://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/) *1/29/2023*  
[Sort a Matrix Problem](https://www.geeksforgeeks.org/sort-given-matrix/) *1/31/2023*

### Programs
[adjacency_list1.cpp](files/graph_practice/adjacency_list1.cpp) *1/22/2023*  
[adjacency_matrix1.cpp](files/graph_practice/adjacency_matrix1.cpp) *1/22/2023*  
[circular linked list](files/circular/main.cpp) *1/28/2023*  
[Sort A Matrix](files/matrix/main.cpp) *2/1/2023*  
[Stack](files/stack/main.cpp) *2/2/2023*

---
### 1/1/2023
#### Code - *Book*
Read more of chapter 17, “Automation”. I’m learning about how an array of “instructions” such as Load, Add, Store, and Halt can be applied to a data array in order to perform arithmetical operations. I can see where this is going: the book is barely scratching the surface of assembly code and showing how it interacts with data.

#### Linux Pocket Guide
Learned how to examine the permissions of a given file or directory: `ls -l myfile` the resulting line will look something like this `-rwxrwxrwx username username timestamp` the 10-char string at the beginning tells what type of list element it is with the first char and then the remaining nine chars show what permissions three different groups have. In the example above, all groups can read, write, and execute.

### 1/2/2023
#### Mastering Data Structures and Algorithms
I can see that this course would be very instructive, and I foresee that I will use it in the future, but I think it might be the wrong choice for the nonce. I realized I’d like to explore C++ more deeply before taking a course solely dedicated to data structures and algos.

#### C++20 Masterclass - *Udemy*
I’m excited about this course. I hope I can complete it in about 3.5 months, but we’ll see! I watched sections 1 through 4. The instructor advised us to watch the environment setup videos for every OS, even if we weren’t using a particular one. This way, we could learn how it is done on each. Ultimately, I got VSCode set up on my Linux machine. We used the terminal to check whether GCC and Clang were installed, then we installed them if they weren’t already installed, then we edited the tasks.json file in our project folder to allow us to easily build with either compiler, and finally we told VSCode to use the C++20 standard in a file called c_cpp_properties.json, which was created after accessing the command palette and entering C/C++:Edit Configurations (UI).

### 1/3/2023
#### Code - *Book*
Currently reading the section of Chapter 17 on making the adding machine more flexible. Now, we include 2 bytes with every instruction opcode to tell the CPU where to perform the instruction. This is more flexible than using two contiguous arrays (instruction array and data array) that must be always synchronized, instruction memory address to data memory address. I find all this very fascinating and I'm eager to make it all more intuitive as I continue studying!

#### C++20 Masterclass
Finished watching sections five and six. I'm glad I did because they helped solidify the VSCode setup process. I like the idea of having a template project folder that I can simply `cp template_project` and `mv template_project project_name`. I am eager to get fully underway with this course, but I'm trying to make sure I don't overwork myself. Slow and steady wins the race, and I'm racing myself.

#### Bare Metal C
I went through the earlier part of Chapter 3 and refreshed myself; key terms are HAL (Hardware Abstraction Layer) and GPIO (General Purpose Input Output). Since I had already written the demo program last time, I simply reviewed it to make sure I understood every part of it. I’m pleased that this book goes so in depth on the build process, compiling and linking. It’s possible that I will breeze through some parts of this book since it is geared toward beginner C programmers, but I know there will be many new concepts scattered throughout.

### 1/4/2023
#### C++20 Masterclass
I worked through all the videos in Section 8. Much of it was review for me, but I still sensed the value in it. Also, it helped to increase playback speed where I already completely understood what was being taught. My biggest takeway was the difference between Core Features, Standard Library and STL (Standard Template Library). The instructor did not go in depth, but I know these categorical distinctions will be useful later on. The demonstration of the `getline()` function was also useful. This is how we used it:  
`std::string name;  
getline(std::cin, name);`

### 1/5/2022
#### C++20 Masterclass
Watched and worked through section 9 videos 39 and 40. Nearly all of this material is review, but once again, I just increase playback speed and skim through them. Occasionally, some simple new concepts have emerged, which is the main reason I don't want to skip anything.  

Yes! Video 41 presented some new material and it all checks out with stackoverflow. The main takeaway from this video was three types of initialization: braced, functional, and assignment. Braced initialization is the preferred method since it does not allow the data to be altered or truncated if the variable is mishandled. [This post](https://stackoverflow.com/questions/18222926/what-are-the-advantages-of-list-initialization-using-curly-braces) on stackoverflow.com explains the concept further - they call it list initialization.  
I also watched video 42 and it was also helpful. This is going to be a great course.

### 1/8/2022
#### Thoughts
I'm chipping away at this C++ course and really enjoying it! However, I've been feeling discouraged since I'm not working on any projects and I've been unsure of what I should be working on. Today I decided to do some research and find out what interests me. First, I looked at Socket Programming, but I think I found that it is merely a component of the larger topic of web programming, a field that I've thought about exploring more. The trouble is that web programming doesn't seem to excite me very much (of course that could change as my experience grows).  

After more browsing, I found the topic that sparked immediate interest IoT (Internet of Things). It includes all the things I think I like: embedded systems, working with C/C++, low-level programming, understanding how data is transmitted over networks via protocols, etc. I might look back at this and chuckle at my obvious inexperience. Anyhow, I need to find what I'm interested in and lean that direction. I need to not set up artificial barriers for myself!

#### C++20 Masterclass
I completed the video 43, fractional numbers. Then, I wrote a practice program, implementing a pythagorean theorem function using some of the principles (braced initialization, setprecision, default arguments) I've learned.  
Video 44, on boolean values, gave me the idea to store multiple boolean values in 1 byte. I wrote a program to do just that.  

I finished the rest of Section 8. I found the auto keyword the most significant: it allows us to use C++ in a more-or-less dynamically-typed fashion. I have yet to see where this keyword is most useful, but I'm sure I will in the coming lectures.    

#### Bare Metal C
I finished chapter 4. The main takeaways were from exploring the files created by the IDE at the creation of the project and from using GDB, the debugger. This chapter helped me appreciate just how much goes on under the hood, all the preliminary steps and initializations that must occur just so I can write my tiny LED-blinking program. HAL\_init() caught my attention the most since it has a catalog of hardware architectures from which it initializes the hardware with the appropriate data. If you can’t tell, I don’t fully understand it yet!

### 1/9/2023
#### Research
I'm exploring potential specializations in technology, and IoT and TinyML currently stand out the most. At the moment, I can't decide between the two!  

I went on LinkedIn to add my certificate from the C Programming Udemy class, create a profile summary that explains what my current job is and how I'm preparing for the future by studying Computer Science, and update my CS50x certification with the verified certificate, which I received a few days ago!

#### C++20 Masterclass
Completed lectures 49 through 51. This stuff was pretty basic! At the end of the lecture on Precedence and Associativity, the instructor explained that a programmer should not rely on the precedence table too much. That is to say, put parentheses in your expressions to make your intentions explicit. This will increase readability and decrease the potential of mishandling data.

#### Bare Metal C
Began working in chapter 4. The first part of the chapter is mainly about data types, so it is just review. Later in the chapter, I see that we’ll be getting to some content that should fill in some knowledge gaps for me.

### 1/10/2023
#### C++20 Masterclass
Sections 52 - 55. Topics covered: Increment Operators, postfix and prefix; Compound Assignment Operators (+=, -=, \*=, /=, %=); Relational Operators (<, >, <=, >=, ==, !=); Logical Operators (&&, ||, !). Once again, this is pretty much all review. I’m glad to go over it, but I’d really like to get into the new stuff more.

### 1/11/2023
#### C++20 Masterclass
Sections 56 - . Video 56 was quite long, but very useful. It covered output formatting with demonstrations of several functions and manipulators that can be applied to std::cout to alter how the data is displayed in the console.

57 was on the numeric\_limits class, which is found in the <limits> library. Once again, I found this very useful: it allows us to print out the range of storable values for a given data type. For instance, using `std::numeric_limits\<unsigned int\>::min()` and `std::numeric_limits<unsigned int>::max()`, we are able to see that the unsigned int data type indeed goes from 0 to over 4 billion.

The weird integral types lecture explained that the int data type is the smallest type with which we can perform arithmetical operations. This is due to the design of the processor. If we take two chars or two shorts and add them, the result will be automatically cast as an int; in order to do this, the compiler has to convert each variable to int beforehand.

With that, I've completed section 9! That's all for today with this course. 

#### Bare Metal C
I read a little more of chapter 4, and it was mostly review again. This is becoming a bit of a trend with my classes. Perhaps I need to be less of a completionist and know when to skim. I’m fine with being a completionist with the C++20 Masterclass, but with this book, I ought to start skimming ahead to content that is new.

The section Standard Integers in chapter 4 was actually very enlightening. The C standard only defines the integral types relative to each other (short is smaller than int is smaller than long). However, on some system, int is 2 bytes, and on others, it's 4 bytes (more common). To deal with this unpredictability, fixed-width data types were added with the stdint.h library (int32\_t). These guarantee a specific width (conditional compilation). However, we can still run into something called argument promotion, which is where a data type like int8\_t is promoted to int32\_t to accomodate a value which cannot be stored in the smaller width. In embedded programming, we don't want data types being manipulated under the hood. We want total control of their width, so that our program runs exactly as intended. Thus, it's better that the value overflow than get promoted.

### 1/12/2023
#### Bare Metal C
I definitely spoke too soon with yesterdays first entry for this book. I'm learning some awesome things now. Chapter 4, starting from Shorthand Operators, started to challenge me: it seems to explain that increment and decrement operators should only be used on their own lines of code, not like this `while (arr[++i]);`. This seems to be perfectly legal C; I'll have to investigate further. Then, we got into Memory-Mapped I/O Registers Using Bit Operations. Here the book introduced us to bitwise operators. I copied down the program on pages 73-74, and It found it probably the most elucidating part of the chapter. Finally, I answered all the questions at the end of the chapter. For question 2b, I found that I needed to clear any values that might be present in the parity bits before reassigning them to a different value:  

```
// clear Parity  
ledRegister &= ~Parity; // Parity is 0b00001100  
// set Parity to 2  
ledRegister |= 0b00001000;  
```

### 1/13/2023
#### C++20 Masterclass
Lecture 62 on Literals. I thought I knew exactly what literals were beforehand, but this lecture gave a more nuanced understanding: at the moment, I would describe a literal as any value that is stored in the program binaries after compilation. In other words, if I have a program that takes input from the user,  

```
int not_a_literal;
std::cout << "Enter an integer: ";
std::cin >> not_a_literal;

std::cout << "You entered " << not_a_literal << std::endl;
```

then I could use a non-literal (not\_a\_literal). This, `int literal;`, must be a literal. QUESTION: if a variable is uninitialized, does that make it a non-literal? I think the answer is yes.

[EDIT from 1/28/2023] My understanding here is incorrect. A literal is in fact simply the value used to initialize a variable.

### 1/14/2023
#### Bare Metal C
Today was a light day, but I did manage to get a little study in. I read quickly through the first 6 pages of chapter 5 since it was entirely review. It was all about loop and conditional statements. I stopped just before the section entitled "Using the Button"; I'm fairly certain this section will provide me with new material to digest.

#### Miscellaneous
I realized I don't have a full understanding of the semiconductor, which is a key component of the modern computer (if not THE key component). I pulled up a tab, [What is a Semiconductor](https://www.techtarget.com/whatis/definition/semiconductor), and did a cursory read through. I fully intend to revisit this topic soon.

### 1/15/2023
#### Bare Metal C
Completed chapter five today, though I've yet to solve all the problems at the end. Here are the main takeaways from Chapter Five starting from the section entitled "Using the Button":

- We were shown three types of input circuitry: pullup, pulldown, and floating. These all have to do with how current is directed before closing the circuit and how it is redirected after closing it.
- When analyzing the code in "The Break Statement" section, I noticed the static keyword and I wanted to refresh myself on its purpose. I found an [article](https://www.geeksforgeeks.org/static-variables-in-c/) on GeeksForGeeks that explains static allocation very well. From there I found another [article](https://www.geeksforgeeks.org/static-variables-in-c/) on the memory layout of C programs. I found the following image very helpful:

![the memory layout of a C program](/images/memoryLayoutC.jpg "Memory layout of a C Program")

BSS, the block of memory where static variables are stored, stands for "Block Starting Symbol". The static keyword causes a variable to be stored in the .bss segment of memory; furthermore, it can be used to make a variable global even if it is declared within some local scope.

### 1/16/2023
#### Bare Metal C
It took me far too long to solve chapter 5 problem 1; it's because I was trying to minimize the number of variables and use only two for loops, printing the product of their iterator variables. I completed the program, but I needed to use one initial for loop to set the column headers (X  0  1  2  3  ...).

I solved problem 2 much quicker and had a lot more fun! I enjoy anything that involves bitwise operations; it feels sneaky. For this problem, I had to write a program that could count the number of bits set to 1 in a 32-bit unsigned integer. I did it by running a for loop 32 times while ANDing the number against a 32-bit test value (0x80000000), only the most significant bit set to 1. If the result of the AND is equal to the test value itself, then a count variable is incremented. This is how I counted the number of bits.

I solved problem 3 this evening. I'm proud of my solution: I was able to make my program more user-friendly by using familiar musical jargon. All the user has to do is specify the TimeSignature and Tempo and then populate the uint8\_t array with the beats on which they want the light to flash.

### 1/17/2023
#### Bare Metal C
Solved problem 4, which asked me to write a program that blinks out "HELLO WORLD" in Morse Code on the Nucleo board LED. Once again, I took it a step further and gave the user the ability to easily change the message as they like. I did this by implementing a Morse Code alphabet matrix and a simple hash function. The user simply types their message into a string literal using only uppercase alpha chars and spaces. The program then interprets this at Morse Code.

Problem 5 tasked me with writing a program that computes the first 10 primes. I wrote a program that computes primes up to an upper bound of 0xFFFF (the maximum value as can be stored in uint16\_t). To reduce time complexity, I used an array that remembers the prime numbers we've already computed and uses only the necessary amount of them to compute the next prime in the sequence. Unfortunately, the space complexity had to increase for the time complexity to decrease; there may yet be a further way to optimize this code, but I'll leave it here for now.

### 1/18/2023
#### Bare Metal C
Solved problems 6 and 7. These were very easy, so I spent most of my time making them as clean looking as possible. Problem 7 asked me to write a program that prints only the vowels from a string. I'm pleased to say that after working with ASCII codes so much now, I was able to recall the codes for the vowels, both upper and lowercase, from memory.

#### C++20 Masterclass
Completed lectures 63 through 66. They were all about "const", "constexpr", and "constinit". I understand const very well at this point: it allows the programmer to make it very clear that the variable should not be altered - in fact, it can't be since the compiler will throw an error if it is altered. CONST makes a variable read-only. CONSTEXPR allows us to specify that a computation should occur at compile time instead of runtime (I still need to better my understanding). CONSTINIT "...ensures that the variable is initialized at compile-time, and that the *static initialization order fiasco* cannot take place ([source](stackoverflow.com/questions/57845131/what-is-constinit-in-c20)). Also, I found an [article](geeksforgeeks.org/understanding-constexper-specifier-in-cpp/) on geeksforgeeks.org that helps clarify what "constexpr" does and how it is different from "const".

#### Linux
I wrote a bash script that streamlines the process of updating the driver for the wifi dongle connected to my desktop. Here's the script:

```
\#!/bin/bash
\# A script that streamlines updating the cudy wifi dongle

cd /home/seandavidreed/cudy_driver/rtl88x2bu_linux

sudo make

sudo make install

sudo modprobe -r 88x2bu

sudo modprobe 88x2bu
```

### 1/19/2022
#### Linux
I wrote another bash script; this one is very simple:

```
\#!/bin/bash

cd /home/seandavidreed/my\_programs/studentlog4.0

./studentlog
```
It’s just an easier way to launch my studentlog console application. Now I just open a console and type in studentlog.

#### C++
[Lecture on constexpr](youtube.com/watch?v=fZjYCQ8dzTc&t=6s)

I watched this video on the constexpr keyword, and it was very helpful! Here’s the notes:

- Why is constexpr interesting?
    - No runtime cost, no need execution time, minimal executable footprint, errors found at compile time, no synchronization concerns.

```
constexpr int const\_3;
// is interchangeable with
static const int const\_3;
// but constexpr works with float, for example
// while static const does not.
```

The video had some examples that were beyond my ken, so I skimmed the latter half of it.


### 1/20/2023
#### C++20 Masterclass
I completed lectures 67-69. They were on implicit and explicit data conversions, implicit conversions as with:

```
int sum {};
double x {4.56};
double y {5.67};
sum = x + y; // the value will be truncated and stored in sum as 10
```

and explicit conversions as with:

```
int sum {};
double x {4.56};
double y {5.67};
sum = static_cast<int>(x + y); // same result as before, but explicitly so
```

#### C++ Practice
I decided to give myself some meaningful programs to write in C++ so I can apply what I'm learning. I've been reading up on the graph data structure, and I found a great resource: [this website](https://www.techiedelight.com/graph-implementation-c-without-using-stl/) gave a great demonstration of a graph class in C++. I pretty much copied the code exactly line-by-line, and it improved my understanding. I'll have to keep wrestling with this concept.

### 1/21/2023
#### Researching the Graph Data Structure
I didn't get much of a chance today to write code, but I did read up on the graph data structure more. I had to stop myself from feeling discouraged: I was feeling the strain of learning a new concept, and I was tempted to criticize myself for feeling that way. I had to remind myself that learning is always hard, and that I was probably feeling tired from working my regular job.

### 1/22/2023
#### Graph Data Structure in C++: [adjacency_list1.cpp](/files/graph_practice/adjacency_list1.cpp)
I did it! I implemented my own graph class in C++! The example I found on techiedelight was indispensible, but when I implemented my own, I tried to do so by thinking through the logic and syntax myself. Moreover, I wrote the constructor such that the user initializes the graph at runtime. After reading on [geeksforgeeks](https://www.geeksforgeeks.org/introduction-to-graphs-data-structure-and-algorithm-tutorials/?ref=lbp), I was able to understand the graph data structure much better. Also, my mind is much sharper today.

I decided to start including practice programs in this daily log repo. That way I can keep a much clearer record of my progress. Hence, I've added the link to the header of this entry.

#### GIT
It's settled. I need to become more proficient with git, and that probably entails taking a short class, or watching in-depth tutorial videos. Let me try to outline the problem I faced today:  
1. Need to clone this repository (programming_log) onto my desktop computer, but I keep getting this error: `Support for password authentication was removed on August 13, 2021`.
2. Try using GCM (git-credential-manager), which I believe I used successfully on my laptop. For some reason, I can't get it working. Even though GCM is configured, running git clone on HTTPS still throws the original error, like gcm is failing to run. Because I'm too fed up to troubleshoot further, I look for other options.
3. Try using SSH (Secure Shell Protocol). Following this tutorial, [What is a Git SSH Key?](https://www.atlassian.com/git/tutorials/git-ssh), I'm able to create a key-pair on my local machine stored in .ssh in my user directory. The final command, `ssh-add -K /Users/you/.ssh/id_rsa`, results in a request for an authenticator pin, which I don't have set up with GitHub, so I ask stackoverflow for help. Turns out I just need to omit `-K` from the command.
4. Go to profile, settings, and SSH and GPG Keys. I add new SSH key, but try as I might, I can't seem to get the correct format for the key even though I'm copy-pasting it from .ssh `Key is invalid. You must supply a key in openssh public key format`. Turns out I'm using the private key, and I need to use the public key (.pub). After troubleshooting further formatting errors, I succeed.
5. Create new directory, initialize it as a local repo, and run `git remote add programming_log git@github.com:seandavidreed/programming_log.git`. I get this warning: `The authenticity of host 'github.com (192.30.252.128)' can't be established`. With further digging, I arrive at [GitHub Docs](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints) from which I learn I can add GitHub public key fingerprints to a file I have to create (known_hosts) in `~/home/seandavidreed/.ssh`. This resolved the warning.
6. Run `git fetch`, which works, and then `git merge`, which doesn't. I get `fatal: no remote for the current branch`. I find out that since I just initialized this local repo, it doesn't have a real branch, `fatal: You are on a branch yet to be born`, and it won't until I commit something. I realize I'm doing this all wrong.
7. Realize that I don't need to create and initialize a local repo; I can just run `git clone git@github.com:seandavidreed/programming_log.git`, which is the clone command with SSH. It works and I now have the remote repo on my desktop, from which I am updating this programming_log.

Oh the suffering. Oh the naivete.

#### Graph Data Structure Again! [adjacency_matrix1.cpp](/files/graph_practice/adjacency_matrix1.cpp)
I decided to try my hand at the adjacency matrix representation of a graph. I can see why the adjacency list is more popular. While the matrix is conceptually easier to understand and implement, the list has a significantly reduced space complexity. I could feel the weight of all the space being used as I wrote the program! I suspect I could optimize that space complexity when I refactor.

### 1/23/2023
#### Research
I didn't get to do my usual study today, but I did create a new Reddit account with the aim of joining several programming subs, where I can hopefully learn more about building my own projects from the community.

I also created an account with OpenAI playground so I could use chatGPT. I was able to test it out, submitting queries such as "write a graph data structure in C++" and a question related to the beauty industry (that Rachel formulated) that only a professional would know. The AI answered both queries expertly. Even though I know that chatGPT is really only recycling and rehashing content created by humans and shared on the internet, the fact that it does it so well makes me worry for the future of disciplines like programming. I Know my fears are somewhat irrational, but I can't help it!

### 1/24/2023
#### Bare Metal C
I read through Chapter six entirely this afternoon. It was on Arrays, Pointers, and Strings, all things I'm well familiar with. Nonetheless, I did have a few takeaways:

1. "The size of the pointer depends on the processor type, not the type of data being pointed to. On our STM32 processor, we have 32-bit addresses, so the pointer will be a 32-bit value.
2. When initializing a pointer, we specify the data type to which it points (uint32\_t *ptr). This does not do anything to the size of the pointer itself, but rather it indicates how the pointer is to be incremented in the case of pointer arithmetic, i.e. (ptr + 1) will move the pointer over by four bytes since a uint32\_t is four bytes in size. It will go from 0xFFE0 to 0xFFE4, for example.

I solved programming problems 1 through 3. Number 3 proved to be a most interesting challenge: "Write a program to scan an array for duplicate numbers that may occur anywhere in the array." The first solution that came to mind was brute-force, touching every element and testing it against every other element for a time complexity of O(n^2). For any sufficiently large array, this method is absurd. I thought of other solutions as well, but ultimately I realized that the best thing to do would be to sort the array beforehand. Naturally, I turned to merge sort. Loosely referencing an old implementation of mine, I wrote another mergesort algo, and in the process, I found that with a few tweaks the mergesort algorithm itself could count the number of duplicates while sorting the array. Here's what I wrote:

```
/*
 * duplicates2.c
 *
 *  Created on: Jan 24, 2023
 *      Author: seandavidreed
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <time.h>

#define TYPE uint16_t
// ARRAY_SIZE cannot be a value larger than can be held
// by the fixed-width data type above
#define ARRAY_SIZE 1000


void initRandomArray(int *arr, int size) {
	srand(time(NULL));
	for (TYPE i = 0; i < size; ++i) {
		arr[i] = rand() % (int)pow(2.0, sizeof(TYPE) * 8.0);
	}
}

void mergeSort(int *arr, int *temp, int i, int j, int *count) {
	// base case
	if (i >= j) return;

	// recursive case
	int mid = (i + j) / 2;
	mergeSort(arr, temp, i, mid, count);
	mergeSort(arr, temp, mid + 1, j, count);

	int lptr = i;
	int rptr = mid + 1;
	int k;

	for (k = i; k <= j; ++k) {
		if (lptr == mid + 1) temp[k] = arr[rptr++];
		else if (rptr == j + 1) temp[k] = arr[lptr++];
		else if (arr[lptr] == arr[rptr]) {
			temp[k] = arr[lptr++];
			(*count)++;
		}
		else if (arr[lptr] < arr[rptr]) temp[k] = arr[lptr++];
		else temp[k] = arr[rptr++];
	}

	for (k = i; k <= j; ++k) {
		arr[k] = temp[k];
	}
}

void printArray(int *arr, int size) {
	for (TYPE i = 0; i < size; ++i) {
		printf("%d ", arr[i]);
	}
	printf("\n");
}

int main() {
	int array[ARRAY_SIZE], temp[ARRAY_SIZE];
	int count = 0;

	initRandomArray(array, ARRAY_SIZE);
	printArray(array, ARRAY_SIZE);

	mergeSort(array, temp, 0, ARRAY_SIZE - 1, &count);
	printArray(array, ARRAY_SIZE);

	printf("Number of Duplicates: %d\n", count);

	return 0;
}
```

### 1/25/2023
#### Bare Metal C
Finished the last two problems in chapter 6, numbers 4 and 5. They were pretty easy. However, I ran into a snag on problem 5; I was trying to pass a char pointer as an argument to my `void capitalize(char *str)` function, which capitalizes the first character of every word beginning with a letter. The problem is when a string is declared like this `char *str = "This is a string.";`, the string is not mutable. I needed to instead declare it like so, `char str[] = "This is a string.";`. Though I've looked into this topic many times, I still find the terminology somewhat abstruse. However, the concept is intact. Here's a resource on the subject: [Character Strings in C](https://www.cs.uic.edu/~jbell/CourseNotes/C_Programming/CharacterStrings.html).

#### Hardware
Woohoo! I successfully test my PIR motion sensor from adafruit. It’s a small feat, but I’m proud of it nonetheless. Here’s a picture: [picture](/images/PIR_sensor.jpeg). I sorted out the configuration by consulting this [documentation](https://learn.adafruit.com/pir-passive-infrared-proximity-motion-sensor/testing-a-pir)

#### C++20 Masterclass
Made my cpp20-masterclass projects folder into a git repository. Now I can work on these projects on my Linux desktop as well! I had to make some adjustments in the .json files, but it was relatively simple. I noticed that if I don’t have the C/C++ Microsoft extension installed, then VSCode won’t recognize the the key-value `“type”: “cppbuild”` in tasks.json.

### 1/26/2023
#### C++20 Masterclass
Completed 72 - 74. All on bitwise operators. The demonstration of data loss via shifting bits left or right was most helpful.

### 1/27/2023
#### C++20 Masterclass
Completed 75 and 76. It was mostly review, but I appreciated the way the information was presented. We were able to clearly demonstrate the behavior of the bitwise logical operators.

#### Data Structures and Algorithms
I need to study DSA alongside my C++ study; that way I have practice problems to tackle with the language. I'm consulting an [article](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=shm) on geeksforgeeks to get a better understanding of DSA. After the overview of Data Structures and Algos, we get into time and space complexity. I decided to plot each complexity function on a graph on [desmos](https://www.desmos.com/). Below is the image I created:

![time complexity](/images/time-complexity.png)

In order from worst to best: O(n!), O(2^n), O(n^2), O(nlogn), O(n), O(logn), O(1).

I also consulted a [list of examples](https://stackoverflow.com/questions/1592649/examples-of-algorithms-which-has-o1-on-log-n-and-olog-n-complexities) for each complexity on stackoverflow.

I tried in vain today to create a circular linked list. I had the right ideas in mind, but my brain was simply too foggy and weary to deliver. Oh well. I'll try again tomorrow.

### 1/28/2023
![Data Structures and Algorithms](images/DSA.png)

#### Data Structures in C++ [Circular Linked List](files/circular/main.cpp)
I successfully implemented the circular linked list! It was actually rather a challenge to wrap my head around it, but in the end I was able to reason it out. I intend to keep studying various data structures and algorithms using C++ and roughly following the image above. I'm reacquainting myself with all things linked lists, and then I'll move on the the matrix and see if there's anything I'm missing there. Moreover, I'd like to see some real life applications for these data structures. For instance, I want to see a tangible use of the circular linked list. Perhaps tomorrow I will search for one.

### 1/29/2023
#### Data Structures in C++ [Circular Linked List](files/circular/main.cpp)
After yesterday's successful implementation of the circular linked list, I went on geeksforgeeks and browsed the practice problems. I found [this problem](https://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/), which enjoined me to write a funtion that splits a circular linked list into two circular linked lists. The problem is listed as medium difficulty, but I made it even harder on myself: I could have written a function that merely copies each half of the linked lists into two new linked lists, but I didn't want to increase time and space complexity that much. I wanted to find a way to manipulate the pointers in the existing linked list and create two lists by simply redirecting the node pointers diametrically-opposed to the head pointer, one to the head itself, and the other to become a new head that then points back to head->previous. Observe the graphic:

![Split a Circular Linked List](images/circlelink_split.png)

Moreover, I wanted to create this split function, which I called `void mitosis(CircleLink& newList)`, as a method inside the CircleLink class. It all works! I had to suffer to get it to work, and I found that my main problem was in reassigning the pointers; I had a hard time keeping it straight which one was pointing where as I redirected them until I created more pointers to hold onto important addresses. Therefore, I succeeded in my initial design, but it may not be worth the amount of extra space I needed for each pointer. I'll be happy with it for now.

### 1/31/2023
#### Data Structures in C++
[Deletion in a Circular Linked List](https://www.geeksforgeeks.org/deletion-circular-linked-list/)

Yesterday after a busy day outside, I wrote a delete node function, and it wasn't working. For the life of me I couldn't figure it out: I thought it was another issue with reassigning the pointer addresses, but this morning I opened up the code and the error stared me in the face:

```
void deleteNode(unsigned value) {
        Node *ptr = head;
        for (int i = 0; i < numNodes; ++i) {
            if (ptr->value = value) {
                ptr->previous->next = ptr->next;
                ptr->next->previous = ptr->previous;
                delete ptr;
                --numNodes;
                return;
            }

            ptr = ptr->next;
        }
    }
```

I clumsily used an assignment operator instead of an equality operator in the if condition. That was all that was wrong!

[Sort a Matrix Problem](https://www.geeksforgeeks.org/sort-given-matrix/)

I started working on a C++ program to sort a matrix, and I found myself perplexed at some of the differences between pointers and arrays. I've learned this stuff before, but it's likely there's a finer-grain understanding I've yet to achieve; I read [this article](https://www.oreilly.com/library/view/understanding-and-using/9781449344535/ch04.html), which helped to clarify some of the distinctions between them. The following is a quote from the article:

>A common misconception is that an array and a pointer are completely interchangeable. An array name is not a pointer. Although an array name can be treated as a pointer at times, and array notation can be used with pointers, they are distinct and cannot always be used in place of each other. Understanding this difference will help you avoid incorrect use of these notations. For example, although the name of an array used by itself will return the array’s address, we cannot use the name by itself as the target of an assignment.

Reading this article brought to mind an old question I've had, namely "what does it mean that an array 'decays' into a pointer when it is passed to a function?" After searching around on the internet, I got a good grasp of the concept of array decay. The quote above holds the key: a pointer and an array name are not identical. The array name, like the pointer, yields the address of the first element, but it also contains with it the sizeof the whole array, which can be accessed by the `sizeof()` operator. Contrarily, if the `sizeof()` operator is run on a pointer, the size of the pointer will be returned. When an array is passed to a function, a pointer to the address held in the array name is passed instead. This can be circumvented by passing the array by reference. Observe the following examples:

```
// This first example will result in pointer decay 
// since the array is passed by value.
#include <iostream>

unsigned long foo(int arr[]) {
    return sizeof(arr);
}

int main() {
    int arr[10] = {};
    std::cout << sizeof(arr) << std::endl; // prints 40
    std::cout << foo(arr) << std::endl; // prints 8 (on 64-bit machine)
    return 0;
}


// This example won't result in pointer decay
// since the array is passed by reference.
// This can also be accomplished with
// unsigned long foo(int (*arr)[10])
#include <iostream>

unsigned long foo(int (&arr)[10]) {
    return sizeof(arr);
}

int main() {
    int arr[10] = {};
    std::cout << sizeof(arr) << std::endl; // prints 40
    std::cout << foo(arr) << std::endl; // prints 40
    return 0;
}
```

### 2/1/2023
#### Data Structures in C++ [Sort A Matrix](files/matrix/main.cpp)
Today I completed the sort algorithm for a matrix. I implemented Selection Sort, which has time complexities of O(n^2) and $\Omega$(n^2). The initial challenge I faced was how to iterate through the matrix in a way that worked for selection sort; I needed to maintain two sub-arrays inside a matrix. The solution was to treat the matrix as an ordinary one-dimensional array. By including the `printAddresses()` function in my `class Matrix`, I was able to see how the arrays were arranged in memory. The addresses in a given row were of course spaced by 4 bytes, the typical width of an int. However, between one row and another, there was a buffer of 16 bytes. My naive hope that they would somehow be contiguous was dashed, so I decided to iterate through the matrix traditionally, with i and j. However, I made the inner loop like this:

```
while (i < _rows) {
	if (matrix[i][j] < matrix[iSmall][jSmall]) {
		iSmall = i;
		jSmall = j;
		changes = 1;
	}
	++j;
	if (j == _cols) {
		++i;
		j = 0;
	}
}
```
The bit at the end below `++j` allowed me to iterate through each row as if they were contiguous. Conceptualizing the matrix as an ordinary array was the key. 

The first iteration I got working included the swap operations in the inner while loop. This meant that worst-case scenario, the number of swaps performed would be O(n^2). However, when I looked it up, the internet kept saying that there should be at worst O(n) swaps. After a quick look on stackoverflow, I learned that I needed to put the swap operations in the outer while loop below the inner loop. In the inner loop, I then needed to keep track of the indices of the current smallest element, not the element itself.

For fun, I analyzed the difference in runtime between these two implementations:

```
O(n^2) swaps vs O(n) swaps
.0126s          .0115s
```
The matrix I used to get these average figures was rather small, hence the one millisecond difference. If the dataset were much larger, the runtime difference would likely be much more noticeable. I had fun with this problem!

#### C++20 Masterclass
Completed lecture 77 on bitmasks. This is the very same content I've been reviewing in Bare Metal C, which I'd like to get back to soon. I'm eager for the time when I can build confidently with C++.

### 2/2/2023
#### C++20 Masterclass
Completed lectures 78 and 79, which concludes Section 12 on Bitwise Operators. I especially liked the example in 79, where we packed RGB values into one 4-byte unsigned int type. With this method, there is one unused byte, but this is still far more efficient than using 12 bytes (in the case of 3 ints) for values that span 0 to 255.

#### Data Structures in C++ [Stack](files/stack/main.cpp)
Running down the list of Data Structures on geeksforgeeks, I implemented a Stack class in C++. Compared to other data structures, this one is fairly easy to build.

#### STM32cubeIDE
I downloaded this IDE today with the hopes of using it to program the Raspberry Pico and the Nucleo F030r8 development board. I'm really eager to get a true embedded project off the ground!

### 2/3/2023
#### C++20 Masterclass
Completed lectures 81 through 84. There was not much new here, so I watched the videos at increased speed. I didn’t have time for much else today!

### 2/4/2023
#### Bare Metal C
I completed chapter 7, which was all about Local Variables and Procedures. The bits on local variables helped sharpen my understanding of static allocation, which occurs at compile time and is hard-coded into a programs binaries before it even runs. That is much clearer now. Using the GDB debugger in STM32 Workbench, we were able to observe function calls being added to the stack. This was especially interesting in the case of the recursive factorial function: I witnessed the stack grow to the necessary size to initiate the functions base case, and then shrink as each stack frame resolved and was destroyed. Tomorrow, I plan to do the practice problems.
